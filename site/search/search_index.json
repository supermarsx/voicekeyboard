{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VoiceKeyboard","text":"<p>VoiceKeyboard is a lightweight voice-to-text utility that listens on hotkeys and transcribes speech using Faster-Whisper and Silero VAD. It provides a small overlay window, a system tray icon, and configurable hotkeys.</p> <p>Features - Faster-Whisper transcription with Silero VAD voice activity detection - Global hotkeys for start/stop and push-to-talk - Minimal Qt overlay window (frameless, always-on-top) - System tray icon with quick actions - Headless and dry-run modes for CI/testing</p> <p>Quickstart - Install dev deps: <code>pip install -r requirements-dev.txt</code> - Run: <code>voicekeyboard</code> - Edit hotkeys: tray \u2192 Settings \u2192 Edit hotkeys\u2026</p> <p>Environment flags - <code>VOICEKB_DRYRUN</code>: skip heavy model downloads (e.g., <code>1</code> in CI/tests) - <code>VOICEKB_HEADLESS</code>: don\u2019t start Qt window or tray (e.g., <code>1</code> in CI) - <code>VOICEKB_AUTOCLOSE_MS</code>: auto-close Qt after N ms (GUI smoke) - <code>VOICEKB_DISABLE_HOTKEYS</code>: disable system-wide hotkeys (CI/shared machines)</p>"},{"location":"development/","title":"Development","text":"<p>Environment - Python 3.9+ - Dev deps: <code>pip install -r requirements-dev.txt</code></p> <p>Common tasks - Lint: <code>ruff check . &amp;&amp; black --check .</code> - Type check: <code>mypy .</code> - Tests: <code>VOICEKB_DRYRUN=1 VOICEKB_HEADLESS=1 pytest</code> - GUI smoke (Linux): <code>VOICEKB_DRYRUN=1 VOICEKB_AUTOCLOSE_MS=500 xvfb-run -a pytest -q tests/test_gui_smoke.py</code> - Pre-commit: <code>pre-commit install</code> to run hooks locally</p> <p>Docs - Build and serve docs: <code>mkdocs serve</code> - Build static site: <code>mkdocs build</code></p> <p>Packaging - PyInstaller specs in <code>packaging/</code> for Linux, Windows, and macOS.</p> <p>CI - GitHub Actions run lint, type checks, tests, and GUI smoke tests in xvfb.</p>"},{"location":"usage/","title":"Usage","text":"<p>Launching - Command: <code>voicekeyboard</code> - The app starts the tray icon and Qt window (unless headless), initializes the STT pipeline, and listens for hotkeys.</p> <p>Hotkeys - Start: configured in <code>settings.ini</code> (default <code>ctrl+shift+a</code>) - Stop: configured in <code>settings.ini</code> (default <code>ctrl+shift+b</code>) - Push-to-talk: press to start, release to stop (default <code>alt+p</code>)</p> <p>Tray actions - Toggle window: show/hide the overlay window - Edit hotkeys: opens a dialog to change keybindings and reloads them immediately - Open settings: opens <code>settings.ini</code> - Restart/Quit: restart or exit the app</p> <p>Configuration - <code>settings.ini</code> stores all preferences. Changes take effect on restart, or immediately for hotkeys changed via the dialog. - Logging is enabled by default and writes to <code>application.log</code>.</p> <p>Testing modes - Dry run: <code>VOICEKB_DRYRUN=1</code> (skips model downloads and VAD init) - Headless: <code>VOICEKB_HEADLESS=1</code> (no window or tray) - GUI auto-close: <code>VOICEKB_AUTOCLOSE_MS=500</code> useful with <code>xvfb-run</code> in CI</p>"},{"location":"api/app/","title":"App","text":""},{"location":"api/app/#voicekeyboard.app","title":"<code>voicekeyboard.app</code>","text":""},{"location":"api/app/#voicekeyboard.app.Generic","title":"<code>Generic</code>","text":"<p>Top-level lifecycle helpers for starting/stopping and utilities.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>class Generic:\n    \"\"\"Top-level lifecycle helpers for starting/stopping and utilities.\"\"\"\n\n    @staticmethod\n    def startup():\n        \"\"\"Initialize settings/logging and, unless headless, start UI services.\"\"\"\n        Generic.startupSettings()\n        headless = os.getenv(\"VOICEKB_HEADLESS\", \"0\") in (\"1\", \"true\", \"True\")\n        if headless:\n            settings.windowShow = False\n            settings.trayIconShow = False\n        if not headless:\n            Generic.startTrayIcon()\n            Generic.startWindow()\n            Generic.waitWindowLabelVar()\n\n    @staticmethod\n    def startupSettings():\n        \"\"\"Load settings from disk and configure logging.\"\"\"\n        settings.load()\n        settings.setLogging()\n\n    @staticmethod\n    def startWindow():\n        \"\"\"Start the Qt window thread (if enabled).\"\"\"\n        from .window import WindowManager\n\n        WindowManager.start()\n\n    @staticmethod\n    def waitWindowLabelVar():\n        \"\"\"Wait for the UI label to be constructed by the Qt thread.\"\"\"\n        from .window import windowLabel\n\n        while True:\n            try:\n                if windowLabel is not None:\n                    return\n            except NameError:\n                pass\n            time.sleep(0.1)\n\n    @staticmethod\n    def openSettings():\n        \"\"\"Open ``settings.ini`` with the OS-default editor/file opener.\"\"\"\n        configFile: str = \"settings.ini\"\n        try:\n            if sys.platform.startswith(\"darwin\"):\n                subprocess.Popen([\"open\", configFile])\n            elif sys.platform.startswith(\"linux\"):\n                subprocess.Popen([\"xdg-open\", configFile])\n            elif os.name == \"nt\":\n                startfile = getattr(os, \"startfile\", None)\n                if callable(startfile):\n                    startfile(configFile)\n            else:\n                logging.warning(\"Unsupported platform.\")\n        except Exception as error:\n            logging.error(f\"Failed to open file with error: {error}\")\n\n    @staticmethod\n    def startTrayIcon():\n        \"\"\"Start the tray icon on a separate thread with callbacks bound.\"\"\"\n        TrayIconManager.start(\n            open_settings_cb=lambda *_: Generic.openSettings(),\n            open_preferences_cb=lambda *_: Generic.openPreferences(),\n            restart_cb=lambda *_: Generic.restart(),\n            exit_cb=lambda *_: Generic._exit(),\n            toggle_window_cb=lambda *_: Generic.toggleWindow(),\n        )\n\n    @staticmethod\n    def cleanup():\n        \"\"\"Delete log file on exit when configured to do so.\"\"\"\n        try:\n            if settings.logDeleteOnExit:\n                os.remove(settings.logFullpath)\n        except Exception as error:\n            from tkinter import messagebox\n\n            messagebox.showerror(\n                \"Log cleanup failed\",\n                f\"Failed to do log cleanup with error: {error}\",\n            )\n\n    @staticmethod\n    def wrapup():\n        \"\"\"Stop tray and persist settings before shutdown.\"\"\"\n        TrayIconManager.stop()\n        settings.save()\n\n    @staticmethod\n    def _exit():\n        \"\"\"Terminate the process after gracefully shutting down subsystems.\"\"\"\n        logging.info(\"Closing application\")\n        Generic.wrapup()\n        logging.debug(\"Finishing shutting down logging and doing os._exit\")\n        logging.shutdown()\n        Generic.cleanup()\n        os._exit(0)\n\n    @staticmethod\n    def restart():\n        \"\"\"Restart the application process with the same arguments.\"\"\"\n        logging.info(\"Restarting application\")\n        Generic.wrapup()\n        settings.save()\n        # Re-exec the Python interpreter with the same args\n        os.execl(sys.executable, sys.executable, *sys.argv)\n\n    @staticmethod\n    def toggleWindow():\n        \"\"\"Toggle visibility of the overlay window without destroying it.\"\"\"\n        from .window import window as _win\n\n        if settings.windowShow:\n            if _win is not None:\n                _win.hide()\n            settings.windowShow = False\n        else:\n            if _win is not None:\n                _win.show()\n            settings.windowShow = True\n\n    @staticmethod\n    def openPreferences():\n        \"\"\"Open the Preferences dialog, unless running in headless mode.\"\"\"\n        headless = os.getenv(\"VOICEKB_HEADLESS\", \"0\") in (\"1\", \"true\", \"True\")\n        if headless:\n            logging.info(\"Headless mode; preferences dialog not shown\")\n            return\n        # Ensure run inside Qt thread\n        from .window import invoke_in_ui\n\n        invoke_in_ui(_show_preferences_dialog)\n</code></pre>"},{"location":"api/app/#voicekeyboard.app.Generic._exit","title":"<code>_exit()</code>  <code>staticmethod</code>","text":"<p>Terminate the process after gracefully shutting down subsystems.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>@staticmethod\ndef _exit():\n    \"\"\"Terminate the process after gracefully shutting down subsystems.\"\"\"\n    logging.info(\"Closing application\")\n    Generic.wrapup()\n    logging.debug(\"Finishing shutting down logging and doing os._exit\")\n    logging.shutdown()\n    Generic.cleanup()\n    os._exit(0)\n</code></pre>"},{"location":"api/app/#voicekeyboard.app.Generic.cleanup","title":"<code>cleanup()</code>  <code>staticmethod</code>","text":"<p>Delete log file on exit when configured to do so.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>@staticmethod\ndef cleanup():\n    \"\"\"Delete log file on exit when configured to do so.\"\"\"\n    try:\n        if settings.logDeleteOnExit:\n            os.remove(settings.logFullpath)\n    except Exception as error:\n        from tkinter import messagebox\n\n        messagebox.showerror(\n            \"Log cleanup failed\",\n            f\"Failed to do log cleanup with error: {error}\",\n        )\n</code></pre>"},{"location":"api/app/#voicekeyboard.app.Generic.openPreferences","title":"<code>openPreferences()</code>  <code>staticmethod</code>","text":"<p>Open the Preferences dialog, unless running in headless mode.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>@staticmethod\ndef openPreferences():\n    \"\"\"Open the Preferences dialog, unless running in headless mode.\"\"\"\n    headless = os.getenv(\"VOICEKB_HEADLESS\", \"0\") in (\"1\", \"true\", \"True\")\n    if headless:\n        logging.info(\"Headless mode; preferences dialog not shown\")\n        return\n    # Ensure run inside Qt thread\n    from .window import invoke_in_ui\n\n    invoke_in_ui(_show_preferences_dialog)\n</code></pre>"},{"location":"api/app/#voicekeyboard.app.Generic.openSettings","title":"<code>openSettings()</code>  <code>staticmethod</code>","text":"<p>Open <code>settings.ini</code> with the OS-default editor/file opener.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>@staticmethod\ndef openSettings():\n    \"\"\"Open ``settings.ini`` with the OS-default editor/file opener.\"\"\"\n    configFile: str = \"settings.ini\"\n    try:\n        if sys.platform.startswith(\"darwin\"):\n            subprocess.Popen([\"open\", configFile])\n        elif sys.platform.startswith(\"linux\"):\n            subprocess.Popen([\"xdg-open\", configFile])\n        elif os.name == \"nt\":\n            startfile = getattr(os, \"startfile\", None)\n            if callable(startfile):\n                startfile(configFile)\n        else:\n            logging.warning(\"Unsupported platform.\")\n    except Exception as error:\n        logging.error(f\"Failed to open file with error: {error}\")\n</code></pre>"},{"location":"api/app/#voicekeyboard.app.Generic.restart","title":"<code>restart()</code>  <code>staticmethod</code>","text":"<p>Restart the application process with the same arguments.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>@staticmethod\ndef restart():\n    \"\"\"Restart the application process with the same arguments.\"\"\"\n    logging.info(\"Restarting application\")\n    Generic.wrapup()\n    settings.save()\n    # Re-exec the Python interpreter with the same args\n    os.execl(sys.executable, sys.executable, *sys.argv)\n</code></pre>"},{"location":"api/app/#voicekeyboard.app.Generic.startTrayIcon","title":"<code>startTrayIcon()</code>  <code>staticmethod</code>","text":"<p>Start the tray icon on a separate thread with callbacks bound.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>@staticmethod\ndef startTrayIcon():\n    \"\"\"Start the tray icon on a separate thread with callbacks bound.\"\"\"\n    TrayIconManager.start(\n        open_settings_cb=lambda *_: Generic.openSettings(),\n        open_preferences_cb=lambda *_: Generic.openPreferences(),\n        restart_cb=lambda *_: Generic.restart(),\n        exit_cb=lambda *_: Generic._exit(),\n        toggle_window_cb=lambda *_: Generic.toggleWindow(),\n    )\n</code></pre>"},{"location":"api/app/#voicekeyboard.app.Generic.startWindow","title":"<code>startWindow()</code>  <code>staticmethod</code>","text":"<p>Start the Qt window thread (if enabled).</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>@staticmethod\ndef startWindow():\n    \"\"\"Start the Qt window thread (if enabled).\"\"\"\n    from .window import WindowManager\n\n    WindowManager.start()\n</code></pre>"},{"location":"api/app/#voicekeyboard.app.Generic.startup","title":"<code>startup()</code>  <code>staticmethod</code>","text":"<p>Initialize settings/logging and, unless headless, start UI services.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>@staticmethod\ndef startup():\n    \"\"\"Initialize settings/logging and, unless headless, start UI services.\"\"\"\n    Generic.startupSettings()\n    headless = os.getenv(\"VOICEKB_HEADLESS\", \"0\") in (\"1\", \"true\", \"True\")\n    if headless:\n        settings.windowShow = False\n        settings.trayIconShow = False\n    if not headless:\n        Generic.startTrayIcon()\n        Generic.startWindow()\n        Generic.waitWindowLabelVar()\n</code></pre>"},{"location":"api/app/#voicekeyboard.app.Generic.startupSettings","title":"<code>startupSettings()</code>  <code>staticmethod</code>","text":"<p>Load settings from disk and configure logging.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>@staticmethod\ndef startupSettings():\n    \"\"\"Load settings from disk and configure logging.\"\"\"\n    settings.load()\n    settings.setLogging()\n</code></pre>"},{"location":"api/app/#voicekeyboard.app.Generic.toggleWindow","title":"<code>toggleWindow()</code>  <code>staticmethod</code>","text":"<p>Toggle visibility of the overlay window without destroying it.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>@staticmethod\ndef toggleWindow():\n    \"\"\"Toggle visibility of the overlay window without destroying it.\"\"\"\n    from .window import window as _win\n\n    if settings.windowShow:\n        if _win is not None:\n            _win.hide()\n        settings.windowShow = False\n    else:\n        if _win is not None:\n            _win.show()\n        settings.windowShow = True\n</code></pre>"},{"location":"api/app/#voicekeyboard.app.Generic.waitWindowLabelVar","title":"<code>waitWindowLabelVar()</code>  <code>staticmethod</code>","text":"<p>Wait for the UI label to be constructed by the Qt thread.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>@staticmethod\ndef waitWindowLabelVar():\n    \"\"\"Wait for the UI label to be constructed by the Qt thread.\"\"\"\n    from .window import windowLabel\n\n    while True:\n        try:\n            if windowLabel is not None:\n                return\n        except NameError:\n            pass\n        time.sleep(0.1)\n</code></pre>"},{"location":"api/app/#voicekeyboard.app.Generic.wrapup","title":"<code>wrapup()</code>  <code>staticmethod</code>","text":"<p>Stop tray and persist settings before shutdown.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>@staticmethod\ndef wrapup():\n    \"\"\"Stop tray and persist settings before shutdown.\"\"\"\n    TrayIconManager.stop()\n    settings.save()\n</code></pre>"},{"location":"api/app/#voicekeyboard.app.Hotkeys","title":"<code>Hotkeys</code>","text":"<p>Backward-compatible facade for registering hotkeys.</p> <p>Internally delegates to :class:<code>HotkeysManager</code> with the current <code>speechConverter</code> callbacks.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>class Hotkeys:\n    \"\"\"Backward-compatible facade for registering hotkeys.\n\n    Internally delegates to :class:`HotkeysManager` with the current\n    ``speechConverter`` callbacks.\n    \"\"\"\n\n    class Load:\n        @staticmethod\n        def startRecording():\n            Hotkeys._manager().register_start()\n\n        @staticmethod\n        def stopRecording():\n            Hotkeys._manager().register_stop()\n\n        @staticmethod\n        def pushToTalk():\n            Hotkeys._manager().register_push_to_talk()\n\n        @staticmethod\n        def allKeys():\n            logging.debug(\"Loading hotkeys\")\n            Hotkeys.Load.startRecording()\n            Hotkeys.Load.stopRecording()\n            Hotkeys.Load.pushToTalk()\n\n    @staticmethod\n    def _manager() -&gt; HotkeysManager:\n        # Late import/creation to avoid init order issues\n        return HotkeysManager(speechConverter.start, speechConverter.stop)\n</code></pre>"},{"location":"api/app/#voicekeyboard.app._show_preferences_dialog","title":"<code>_show_preferences_dialog()</code>","text":"<p>Show the Preferences dialog modally inside the Qt thread.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>def _show_preferences_dialog():\n    \"\"\"Show the Preferences dialog modally inside the Qt thread.\"\"\"\n    from .preferences import PreferencesDialog\n\n    PreferencesDialog.show_modal(on_apply=reload_hotkeys_service)\n</code></pre>"},{"location":"api/app/#voicekeyboard.app.main","title":"<code>main()</code>","text":"<p>Entry point for console script <code>voicekeyboard</code>.</p> <p>Instantiates the STT subsystem and starts the hotkeys service, then idles until a KeyboardInterrupt is received.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Entry point for console script ``voicekeyboard``.\n\n    Instantiates the STT subsystem and starts the hotkeys service, then idles\n    until a KeyboardInterrupt is received.\n    \"\"\"\n    global speechConverter\n    global _hotkeys_service\n    speechConverter = SpeechConverter()\n    # Start hotkeys in a dedicated service thread\n    _hotkeys_service = HotkeysService(Hotkeys._manager())\n    _hotkeys_service.start()\n\n    # Main loop; in GUI mode, Qt runs on its own thread\n    try:\n        while True:\n            time.sleep(0.1)\n    except KeyboardInterrupt:\n        try:\n            _hotkeys_service.stop()\n        finally:\n            Generic._exit()\n</code></pre>"},{"location":"api/app/#voicekeyboard.app.reload_hotkeys_service","title":"<code>reload_hotkeys_service()</code>","text":"<p>Restart the hotkeys service to apply changed bindings from settings.</p> Source code in <code>voicekeyboard\\app.py</code> <pre><code>def reload_hotkeys_service() -&gt; None:\n    \"\"\"Restart the hotkeys service to apply changed bindings from settings.\"\"\"\n    # Recreate manager using updated settings and restart service safely\n    try:\n        from .hotkeys import HotkeysService as _HS\n\n        global _hotkeys_service\n        if isinstance(_hotkeys_service, _HS):\n            _hotkeys_service.restart_with_manager(Hotkeys._manager())\n        else:\n            # Fallback: create anew if global not initialized\n            _hotkeys_service = _HS(Hotkeys._manager())\n            _hotkeys_service.start()\n    except Exception as e:\n        logging.error(f\"Failed to reload hotkeys service: {e}\")\n</code></pre>"},{"location":"api/hotkeys/","title":"Hotkeys","text":""},{"location":"api/hotkeys/#voicekeyboard.hotkeys","title":"<code>voicekeyboard.hotkeys</code>","text":""},{"location":"api/hotkeys/#voicekeyboard.hotkeys.HotkeysManager","title":"<code>HotkeysManager</code>","text":"Source code in <code>voicekeyboard\\hotkeys.py</code> <pre><code>class HotkeysManager:\n    def __init__(self, start_fn: Callable[[], None], stop_fn: Callable[[], None]):\n        self.start_fn: Callable[[], None] = start_fn\n        self.stop_fn: Callable[[], None] = stop_fn\n\n    def register_start(self):\n        \"\"\"Register global start-recording hotkey.\"\"\"\n        keyboard.add_hotkey(settings.hotkeyStartRecording, self.start_fn)\n        logging.debug(f\"Loaded start recording hotkey: {settings.hotkeyStartRecording}\")\n\n    def register_stop(self):\n        \"\"\"Register global stop-recording hotkey.\"\"\"\n        keyboard.add_hotkey(settings.hotkeyStopRecording, self.stop_fn)\n        logging.debug(f\"Loaded stop recording hotkey: {settings.hotkeyStopRecording}\")\n\n    def register_push_to_talk(self):\n        \"\"\"Register push-to-talk: press to start, release to stop.\"\"\"\n        keyboard.on_press_key(settings.hotkeyPushToTalk, lambda _e: self.start_fn())\n        keyboard.on_release_key(settings.hotkeyPushToTalk, lambda _e: self.stop_fn())\n        logging.debug(f\"Loaded push-to-talk recording hotkey: {settings.hotkeyPushToTalk}\")\n\n    def register_all(self):\n        \"\"\"Register all configured hotkeys with the OS.\"\"\"\n        logging.debug(\"Loading hotkeys\")\n        self.register_start()\n        self.register_stop()\n        self.register_push_to_talk()\n</code></pre>"},{"location":"api/hotkeys/#voicekeyboard.hotkeys.HotkeysManager.register_all","title":"<code>register_all()</code>","text":"<p>Register all configured hotkeys with the OS.</p> Source code in <code>voicekeyboard\\hotkeys.py</code> <pre><code>def register_all(self):\n    \"\"\"Register all configured hotkeys with the OS.\"\"\"\n    logging.debug(\"Loading hotkeys\")\n    self.register_start()\n    self.register_stop()\n    self.register_push_to_talk()\n</code></pre>"},{"location":"api/hotkeys/#voicekeyboard.hotkeys.HotkeysManager.register_push_to_talk","title":"<code>register_push_to_talk()</code>","text":"<p>Register push-to-talk: press to start, release to stop.</p> Source code in <code>voicekeyboard\\hotkeys.py</code> <pre><code>def register_push_to_talk(self):\n    \"\"\"Register push-to-talk: press to start, release to stop.\"\"\"\n    keyboard.on_press_key(settings.hotkeyPushToTalk, lambda _e: self.start_fn())\n    keyboard.on_release_key(settings.hotkeyPushToTalk, lambda _e: self.stop_fn())\n    logging.debug(f\"Loaded push-to-talk recording hotkey: {settings.hotkeyPushToTalk}\")\n</code></pre>"},{"location":"api/hotkeys/#voicekeyboard.hotkeys.HotkeysManager.register_start","title":"<code>register_start()</code>","text":"<p>Register global start-recording hotkey.</p> Source code in <code>voicekeyboard\\hotkeys.py</code> <pre><code>def register_start(self):\n    \"\"\"Register global start-recording hotkey.\"\"\"\n    keyboard.add_hotkey(settings.hotkeyStartRecording, self.start_fn)\n    logging.debug(f\"Loaded start recording hotkey: {settings.hotkeyStartRecording}\")\n</code></pre>"},{"location":"api/hotkeys/#voicekeyboard.hotkeys.HotkeysManager.register_stop","title":"<code>register_stop()</code>","text":"<p>Register global stop-recording hotkey.</p> Source code in <code>voicekeyboard\\hotkeys.py</code> <pre><code>def register_stop(self):\n    \"\"\"Register global stop-recording hotkey.\"\"\"\n    keyboard.add_hotkey(settings.hotkeyStopRecording, self.stop_fn)\n    logging.debug(f\"Loaded stop recording hotkey: {settings.hotkeyStopRecording}\")\n</code></pre>"},{"location":"api/hotkeys/#voicekeyboard.hotkeys.HotkeysService","title":"<code>HotkeysService</code>","text":"Source code in <code>voicekeyboard\\hotkeys.py</code> <pre><code>class HotkeysService:\n    def __init__(self, manager: HotkeysManager):\n        self.manager: HotkeysManager = manager\n        self._thread: Optional[threading.Thread] = None\n        self._stop_event: threading.Event = threading.Event()\n\n    def start(self):\n        \"\"\"Start the service thread and register all hotkeys unless disabled.\"\"\"\n        if self._thread and self._thread.is_alive():\n            return\n        # Optionally disable via env for CI/local opt-out\n        if os.getenv(\"VOICEKB_DISABLE_HOTKEYS\", \"0\") in (\"1\", \"true\", \"True\"):\n            logging.info(\"Hotkeys disabled via VOICEKB_DISABLE_HOTKEYS\")\n            return\n        self._stop_event.clear()\n        self._thread = threading.Thread(target=self._run, name=\"hotkeys\", daemon=True)\n        self._thread.start()\n\n    def _run(self):\n        \"\"\"Thread target: register hotkeys and keep the service alive.\"\"\"\n        try:\n            self.manager.register_all()\n            logging.info(\"Hotkeys registered and service running\")\n            while not self._stop_event.is_set():\n                time.sleep(0.1)\n        except Exception as e:\n            logging.error(f\"Hotkeys service error: {e}\")\n\n    def restart_with_manager(self, manager: HotkeysManager) -&gt; None:\n        \"\"\"Stop the service, swap the manager, and start again.\"\"\"\n        self.stop()\n        self.manager = manager\n        self.start()\n\n    def stop(self):\n        \"\"\"Stop the service thread and clear registered hotkeys.\"\"\"\n        self._stop_event.set()\n        try:\n            keyboard.clear_all_hotkeys()\n        except Exception:\n            pass\n        if self._thread and self._thread.is_alive():\n            self._thread.join(timeout=1)\n        self._thread = None\n</code></pre>"},{"location":"api/hotkeys/#voicekeyboard.hotkeys.HotkeysService._run","title":"<code>_run()</code>","text":"<p>Thread target: register hotkeys and keep the service alive.</p> Source code in <code>voicekeyboard\\hotkeys.py</code> <pre><code>def _run(self):\n    \"\"\"Thread target: register hotkeys and keep the service alive.\"\"\"\n    try:\n        self.manager.register_all()\n        logging.info(\"Hotkeys registered and service running\")\n        while not self._stop_event.is_set():\n            time.sleep(0.1)\n    except Exception as e:\n        logging.error(f\"Hotkeys service error: {e}\")\n</code></pre>"},{"location":"api/hotkeys/#voicekeyboard.hotkeys.HotkeysService.restart_with_manager","title":"<code>restart_with_manager(manager)</code>","text":"<p>Stop the service, swap the manager, and start again.</p> Source code in <code>voicekeyboard\\hotkeys.py</code> <pre><code>def restart_with_manager(self, manager: HotkeysManager) -&gt; None:\n    \"\"\"Stop the service, swap the manager, and start again.\"\"\"\n    self.stop()\n    self.manager = manager\n    self.start()\n</code></pre>"},{"location":"api/hotkeys/#voicekeyboard.hotkeys.HotkeysService.start","title":"<code>start()</code>","text":"<p>Start the service thread and register all hotkeys unless disabled.</p> Source code in <code>voicekeyboard\\hotkeys.py</code> <pre><code>def start(self):\n    \"\"\"Start the service thread and register all hotkeys unless disabled.\"\"\"\n    if self._thread and self._thread.is_alive():\n        return\n    # Optionally disable via env for CI/local opt-out\n    if os.getenv(\"VOICEKB_DISABLE_HOTKEYS\", \"0\") in (\"1\", \"true\", \"True\"):\n        logging.info(\"Hotkeys disabled via VOICEKB_DISABLE_HOTKEYS\")\n        return\n    self._stop_event.clear()\n    self._thread = threading.Thread(target=self._run, name=\"hotkeys\", daemon=True)\n    self._thread.start()\n</code></pre>"},{"location":"api/hotkeys/#voicekeyboard.hotkeys.HotkeysService.stop","title":"<code>stop()</code>","text":"<p>Stop the service thread and clear registered hotkeys.</p> Source code in <code>voicekeyboard\\hotkeys.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the service thread and clear registered hotkeys.\"\"\"\n    self._stop_event.set()\n    try:\n        keyboard.clear_all_hotkeys()\n    except Exception:\n        pass\n    if self._thread and self._thread.is_alive():\n        self._thread.join(timeout=1)\n    self._thread = None\n</code></pre>"},{"location":"api/preferences/","title":"Preferences","text":""},{"location":"api/preferences/#voicekeyboard.preferences","title":"<code>voicekeyboard.preferences</code>","text":"<p>Preferences dialog for editing hotkeys at runtime.</p> <p>Provides a simple modal dialog to edit the three hotkey combinations. On save, changes are persisted via settings.save() and a provided callback is invoked to reload hotkeys in the running app.</p>"},{"location":"api/preferences/#voicekeyboard.preferences.PreferencesDialog","title":"<code>PreferencesDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Modal dialog that edits start/stop/push-to-talk hotkeys.</p> Source code in <code>voicekeyboard\\preferences.py</code> <pre><code>class PreferencesDialog(QDialog):\n    \"\"\"Modal dialog that edits start/stop/push-to-talk hotkeys.\"\"\"\n\n    def __init__(self, on_apply: Callable[[], None]):\n        super().__init__()\n        self.setWindowTitle(\"VoiceKeyboard Preferences\")\n        self.on_apply = on_apply\n\n        layout = QVBoxLayout()\n\n        # Hotkey fields\n        self.start_edit = QLineEdit(settings.hotkeyStartRecording)\n        self.stop_edit = QLineEdit(settings.hotkeyStopRecording)\n        self.ptt_edit = QLineEdit(settings.hotkeyPushToTalk)\n\n        layout.addLayout(self._row(\"Start hotkey:\", self.start_edit))\n        layout.addLayout(self._row(\"Stop hotkey:\", self.stop_edit))\n        layout.addLayout(self._row(\"Push-to-talk:\", self.ptt_edit))\n\n        # Buttons\n        buttons = QHBoxLayout()\n        save_btn = QPushButton(\"Save\")\n        cancel_btn = QPushButton(\"Cancel\")\n        save_btn.clicked.connect(self._save)\n        cancel_btn.clicked.connect(self.reject)\n        buttons.addWidget(save_btn)\n        buttons.addWidget(cancel_btn)\n        layout.addLayout(buttons)\n\n        self.setLayout(layout)\n\n    def _row(self, label: str, line: QLineEdit):\n        \"\"\"Create a labeled row with a QLineEdit control.\"\"\"\n        row = QHBoxLayout()\n        row.addWidget(QLabel(label))\n        row.addWidget(line)\n        return row\n\n    def _save(self):\n        \"\"\"Persist changes and invoke the supplied reload callback.\"\"\"\n        # Persist new hotkeys\n        settings.hotkeyStartRecording = self.start_edit.text().strip()\n        settings.hotkeyStopRecording = self.stop_edit.text().strip()\n        settings.hotkeyPushToTalk = self.ptt_edit.text().strip()\n        settings.save()\n        # Trigger hotkeys reload\n        try:\n            self.on_apply()\n        finally:\n            self.accept()\n\n    @staticmethod\n    def show_modal(on_apply: Callable[[], None]):\n        \"\"\"Convenience wrapper to construct and display the dialog modally.\"\"\"\n        dlg = PreferencesDialog(on_apply)\n        dlg.exec()\n</code></pre>"},{"location":"api/preferences/#voicekeyboard.preferences.PreferencesDialog._row","title":"<code>_row(label, line)</code>","text":"<p>Create a labeled row with a QLineEdit control.</p> Source code in <code>voicekeyboard\\preferences.py</code> <pre><code>def _row(self, label: str, line: QLineEdit):\n    \"\"\"Create a labeled row with a QLineEdit control.\"\"\"\n    row = QHBoxLayout()\n    row.addWidget(QLabel(label))\n    row.addWidget(line)\n    return row\n</code></pre>"},{"location":"api/preferences/#voicekeyboard.preferences.PreferencesDialog._save","title":"<code>_save()</code>","text":"<p>Persist changes and invoke the supplied reload callback.</p> Source code in <code>voicekeyboard\\preferences.py</code> <pre><code>def _save(self):\n    \"\"\"Persist changes and invoke the supplied reload callback.\"\"\"\n    # Persist new hotkeys\n    settings.hotkeyStartRecording = self.start_edit.text().strip()\n    settings.hotkeyStopRecording = self.stop_edit.text().strip()\n    settings.hotkeyPushToTalk = self.ptt_edit.text().strip()\n    settings.save()\n    # Trigger hotkeys reload\n    try:\n        self.on_apply()\n    finally:\n        self.accept()\n</code></pre>"},{"location":"api/preferences/#voicekeyboard.preferences.PreferencesDialog.show_modal","title":"<code>show_modal(on_apply)</code>  <code>staticmethod</code>","text":"<p>Convenience wrapper to construct and display the dialog modally.</p> Source code in <code>voicekeyboard\\preferences.py</code> <pre><code>@staticmethod\ndef show_modal(on_apply: Callable[[], None]):\n    \"\"\"Convenience wrapper to construct and display the dialog modally.\"\"\"\n    dlg = PreferencesDialog(on_apply)\n    dlg.exec()\n</code></pre>"},{"location":"api/settings/","title":"Settings","text":""},{"location":"api/settings/#voicekeyboard.settings","title":"<code>voicekeyboard.settings</code>","text":""},{"location":"api/settings/#voicekeyboard.settings.SettingsManager","title":"<code>SettingsManager</code>","text":"<p>Singleton container for application configuration.</p> <p>Values are initialized with reasonable defaults and can be overridden by loading from an INI file via :meth:<code>load</code>.</p> Source code in <code>voicekeyboard\\settings.py</code> <pre><code>class SettingsManager:\n    \"\"\"Singleton container for application configuration.\n\n    Values are initialized with reasonable defaults and can be overridden by\n    loading from an INI file via :meth:`load`.\n    \"\"\"\n\n    _instance = None\n\n    def __new__(cls, *args, **kwargs):\n        if not cls._instance:\n            cls._instance = super(SettingsManager, cls).__new__(cls, *args, **kwargs)\n        return cls._instance\n\n    def __init__(self):\n        self.windowShow: bool = True\n        self.windowDaemon: bool = True\n        self.windowHeight: int = 50\n        self.windowWidth: int = 200\n        self.windowPosRestoreOnStartup: bool = True\n        self.windowPosX: int = 0\n        self.windowPosY: int = 0\n        self.windowDraggable: bool = True\n        self.windowBackgroundColor: str = \"black\"\n        self.windowBorderEnabled: bool = True\n        self.windowBorderColor: str = \"grey\"\n        self.windowBorderWidthPx: int = 1\n        self.windowBorderType: str = \"solid\"\n        self.windowTextColor: str = \"white\"\n        self.windowTextSizePx: int = 13\n        self.windowTextFontType: str = \"'Inconsolata', monospace\"\n        self.windowTextFontWeight: int = 800\n        self.windowOpacityEnabled: bool = True\n        self.windowOpacity: float = 0.78\n        self.windowBlurBackgroundEnabled: bool = False\n        self.windowBlurBackgroundPeriod: int = 100\n        self.windowBlurBackgroundStrength: float = 2.0\n        self.windowClipToScreenBorder: bool = True\n        self.windowKeepOnTop: bool = True\n        self.windowFrameless: bool = True\n        self.trayIconShow: bool = True\n        self.trayIconDaemon: bool = True\n        self.pushToTalk: bool = False\n        self.hotkeyStartRecording: str = \"ctrl+shift+a\"\n        self.hotkeyStopRecording: str = \"ctrl+shift+b\"\n        self.hotkeyPushToTalk: str = \"alt+p\"\n        self.launchAtStartup: bool = False\n        self.log: bool = True\n        self.logOverwrite: bool = False\n        self.logFilemode: str = \"\"\n        self.logEncoding: str = \"utf-8\"\n        self.logLevel: int = 10\n        self.logFilename: str = \"application.log\"\n        from typing import Optional\n\n        self.logFilepath: Optional[str] = None\n        self.logFullpath: str = \"\"\n        self.logDeleteOnExit: bool = False\n        self.windowTitle: str = \"VoiceKeyboard\"\n        self.labelWindowWelcome: str = \"Welcome to Voice Keyboard\"\n        self.labelTrayIconTitle: str = \"VoiceKeyboard\"\n        self.labelTrayIconName: str = \"VoiceKeyboard\"\n        self.labelTrayMenuTitle: str = \"VoiceKeyboard\"\n        self.labelTrayMenuToggleWindow: str = \"Toggle window\"\n        self.labelTrayMenuOpenSettings: str = \"Open settings\"\n        self.labelTrayMenuEditHotkeys: str = \"Edit hotkeys\"\n        self.labelTrayMenuExit: str = \"Quit\"\n        self.labelTrayMenuSettings: str = \"Settings\"\n        self.labelTrayMenuDivider1: str = \"---\"\n        self.labelTrayMenuRestart: str = \"Restart\"\n        self.settingsJustUseDefaults: bool = True\n        self.whisperModel: str = \"medium\"\n        self.whisperDevice: str = \"cuda\"\n        self.whisperComputeType: str = \"float16\"\n        self.whisperCpuThreads: int = 0\n        self.whisperNumWorkers: int = 1\n        self.whisperLanguage: str = \"pt\"\n        self.audioChannels: int = 1\n        self.audioSampleRate: int = 16000\n        self.audioChunkDuration: float = 1.0\n        self.audioChunkSize: int = int(self.audioSampleRate * self.audioChunkDuration)\n        self.audioChunkOverlapDuration: float = 0.2\n        self.audioChunkOverlapSize: int = int(self.audioSampleRate * self.audioChunkOverlapDuration)\n        self.vadForceRedownload: bool = False\n\n    def load(self, configFile: str = \"settings.ini\"):\n        \"\"\"Load settings from an INI file.\n\n        Honors ``settingsJustUseDefaults`` to short-circuit loading when set to\n        a truthy value within the file.\n        \"\"\"\n        try:\n            config: ConfigParser = ConfigParser()\n            # Preserve option case\n            def _identity(s: str) -&gt; str:\n                return s\n\n            from typing import Callable, cast\n\n            config.optionxform = cast(Callable[[str], str], _identity)  # type: ignore[assignment]\n            if not os.path.isfile(configFile):\n                raise Exception(f\"File not found: {configFile}\")\n            config.read(configFile)\n            if \"Configuration\" in config:\n                for key, value in config[\"Configuration\"].items():\n                    if (\n                        hasattr(self, key)\n                        and (key == \"settingsJustUseDefaults\")\n                        and (value.lower() in (\"true\", \"1\", \"yes\"))\n                        and (getattr(self, key) is True)\n                    ):\n                        # Respect file flag only when the current instance also opts in\n                        return None\n                for key, value in config[\"Configuration\"].items():\n                    if hasattr(self, key):\n                        current_value = getattr(self, key)\n                        if isinstance(current_value, bool):\n                            setattr(self, key, value.lower() in (\"true\", \"1\", \"yes\"))\n                        elif isinstance(current_value, int):\n                            setattr(self, key, int(value))\n                        elif isinstance(current_value, float):\n                            setattr(self, key, float(value))\n                        elif current_value is None:\n                            setattr(self, key, None if value.lower() == \"none\" else value)\n                        else:\n                            setattr(self, key, value)\n            logging.info(\"Loaded settings from configuration file\")\n        except Exception as error:\n            logging.error(\"Failed to load settings from configuration file\")\n            messagebox.showerror(\"Failed to load settings\", f\"Failed to load settings: {error}\")\n\n    def save(self, configFile=\"settings.ini\"):\n        \"\"\"Persist current settings to an INI file.\"\"\"\n        try:\n            logging.debug(\"Saving settings to configuration file\")\n            config: ConfigParser = ConfigParser()\n            # Preserve option case\n            def _identity(s: str) -&gt; str:\n                return s\n\n            from typing import Callable, cast\n\n            config.optionxform = cast(Callable[[str], str], _identity)  # type: ignore[assignment]\n            config[\"Configuration\"] = {\n                key: str(getattr(self, key)) if getattr(self, key) is not None else \"None\"\n                for key in vars(self)\n            }\n            with open(configFile, \"w\") as file:\n                config.write(file)\n            logging.info(\"Saved settings to configuration file\")\n        except Exception as error:\n            logging.error(f\"Failed to save settings: {error}\")\n        else:\n            logging.info(\"Saved settings successfully\")\n\n    def setLogging(self):\n        \"\"\"Configure application logging.\n\n        Creates a file handler (to ``logFullpath``) and a console handler using\n        the configured level and encoding.\n        \"\"\"\n        try:\n            if settings.log is False:\n                return\n            settings.logFilemode = \"w\" if settings.logOverwrite else \"a\"\n            settings.logFullpath = (\n                os.path.join(settings.logFilepath, settings.logFilename)\n                if settings.logFilepath\n                else settings.logFilename\n            )\n            logging.basicConfig(\n                level=settings.logLevel,\n                format=\"%(asctime)s - [%(threadName)s] - %(levelname)s - %(message)s\",\n                handlers=[\n                    logging.FileHandler(\n                        settings.logFullpath,\n                        settings.logFilemode,\n                        settings.logEncoding,\n                    ),\n                    logging.StreamHandler(),\n                ],\n            )\n            logging.debug(\"Debug logging enabled\")\n            logging.info(\"Informational logging enabled\")\n            logging.info(\"Logging has been set\")\n        except Exception as error:\n            messagebox.showerror(\n                \"Failed to set logging\", f\"Failed to set logging with exception: {error}\"\n            )\n\n    def loadHotkeys(self):\n        \"\"\"Register all hotkeys through the Hotkeys facade.\"\"\"\n        from .app import Hotkeys  # local import to avoid cycles\n\n        try:\n            logging.debug(\"Loading hotkeys\")\n            Hotkeys.Load.allKeys()\n        except Exception as error:\n            logging.error(f\"Failed to load hotkeys with error: {error}\")\n        else:\n            logging.info(\"Hotkeys have been loaded\")\n\n    def debugDumpToConsole(self):\n        \"\"\"Print all settings and their current values to stdout (debug aid).\"\"\"\n        print(\"Dumping settings values to console\")\n        for key in self.__dict__.keys():\n            print(f\"{key}: {getattr(self, key)}\")\n</code></pre>"},{"location":"api/settings/#voicekeyboard.settings.SettingsManager.debugDumpToConsole","title":"<code>debugDumpToConsole()</code>","text":"<p>Print all settings and their current values to stdout (debug aid).</p> Source code in <code>voicekeyboard\\settings.py</code> <pre><code>def debugDumpToConsole(self):\n    \"\"\"Print all settings and their current values to stdout (debug aid).\"\"\"\n    print(\"Dumping settings values to console\")\n    for key in self.__dict__.keys():\n        print(f\"{key}: {getattr(self, key)}\")\n</code></pre>"},{"location":"api/settings/#voicekeyboard.settings.SettingsManager.load","title":"<code>load(configFile='settings.ini')</code>","text":"<p>Load settings from an INI file.</p> <p>Honors <code>settingsJustUseDefaults</code> to short-circuit loading when set to a truthy value within the file.</p> Source code in <code>voicekeyboard\\settings.py</code> <pre><code>def load(self, configFile: str = \"settings.ini\"):\n    \"\"\"Load settings from an INI file.\n\n    Honors ``settingsJustUseDefaults`` to short-circuit loading when set to\n    a truthy value within the file.\n    \"\"\"\n    try:\n        config: ConfigParser = ConfigParser()\n        # Preserve option case\n        def _identity(s: str) -&gt; str:\n            return s\n\n        from typing import Callable, cast\n\n        config.optionxform = cast(Callable[[str], str], _identity)  # type: ignore[assignment]\n        if not os.path.isfile(configFile):\n            raise Exception(f\"File not found: {configFile}\")\n        config.read(configFile)\n        if \"Configuration\" in config:\n            for key, value in config[\"Configuration\"].items():\n                if (\n                    hasattr(self, key)\n                    and (key == \"settingsJustUseDefaults\")\n                    and (value.lower() in (\"true\", \"1\", \"yes\"))\n                    and (getattr(self, key) is True)\n                ):\n                    # Respect file flag only when the current instance also opts in\n                    return None\n            for key, value in config[\"Configuration\"].items():\n                if hasattr(self, key):\n                    current_value = getattr(self, key)\n                    if isinstance(current_value, bool):\n                        setattr(self, key, value.lower() in (\"true\", \"1\", \"yes\"))\n                    elif isinstance(current_value, int):\n                        setattr(self, key, int(value))\n                    elif isinstance(current_value, float):\n                        setattr(self, key, float(value))\n                    elif current_value is None:\n                        setattr(self, key, None if value.lower() == \"none\" else value)\n                    else:\n                        setattr(self, key, value)\n        logging.info(\"Loaded settings from configuration file\")\n    except Exception as error:\n        logging.error(\"Failed to load settings from configuration file\")\n        messagebox.showerror(\"Failed to load settings\", f\"Failed to load settings: {error}\")\n</code></pre>"},{"location":"api/settings/#voicekeyboard.settings.SettingsManager.loadHotkeys","title":"<code>loadHotkeys()</code>","text":"<p>Register all hotkeys through the Hotkeys facade.</p> Source code in <code>voicekeyboard\\settings.py</code> <pre><code>def loadHotkeys(self):\n    \"\"\"Register all hotkeys through the Hotkeys facade.\"\"\"\n    from .app import Hotkeys  # local import to avoid cycles\n\n    try:\n        logging.debug(\"Loading hotkeys\")\n        Hotkeys.Load.allKeys()\n    except Exception as error:\n        logging.error(f\"Failed to load hotkeys with error: {error}\")\n    else:\n        logging.info(\"Hotkeys have been loaded\")\n</code></pre>"},{"location":"api/settings/#voicekeyboard.settings.SettingsManager.save","title":"<code>save(configFile='settings.ini')</code>","text":"<p>Persist current settings to an INI file.</p> Source code in <code>voicekeyboard\\settings.py</code> <pre><code>def save(self, configFile=\"settings.ini\"):\n    \"\"\"Persist current settings to an INI file.\"\"\"\n    try:\n        logging.debug(\"Saving settings to configuration file\")\n        config: ConfigParser = ConfigParser()\n        # Preserve option case\n        def _identity(s: str) -&gt; str:\n            return s\n\n        from typing import Callable, cast\n\n        config.optionxform = cast(Callable[[str], str], _identity)  # type: ignore[assignment]\n        config[\"Configuration\"] = {\n            key: str(getattr(self, key)) if getattr(self, key) is not None else \"None\"\n            for key in vars(self)\n        }\n        with open(configFile, \"w\") as file:\n            config.write(file)\n        logging.info(\"Saved settings to configuration file\")\n    except Exception as error:\n        logging.error(f\"Failed to save settings: {error}\")\n    else:\n        logging.info(\"Saved settings successfully\")\n</code></pre>"},{"location":"api/settings/#voicekeyboard.settings.SettingsManager.setLogging","title":"<code>setLogging()</code>","text":"<p>Configure application logging.</p> <p>Creates a file handler (to <code>logFullpath</code>) and a console handler using the configured level and encoding.</p> Source code in <code>voicekeyboard\\settings.py</code> <pre><code>def setLogging(self):\n    \"\"\"Configure application logging.\n\n    Creates a file handler (to ``logFullpath``) and a console handler using\n    the configured level and encoding.\n    \"\"\"\n    try:\n        if settings.log is False:\n            return\n        settings.logFilemode = \"w\" if settings.logOverwrite else \"a\"\n        settings.logFullpath = (\n            os.path.join(settings.logFilepath, settings.logFilename)\n            if settings.logFilepath\n            else settings.logFilename\n        )\n        logging.basicConfig(\n            level=settings.logLevel,\n            format=\"%(asctime)s - [%(threadName)s] - %(levelname)s - %(message)s\",\n            handlers=[\n                logging.FileHandler(\n                    settings.logFullpath,\n                    settings.logFilemode,\n                    settings.logEncoding,\n                ),\n                logging.StreamHandler(),\n            ],\n        )\n        logging.debug(\"Debug logging enabled\")\n        logging.info(\"Informational logging enabled\")\n        logging.info(\"Logging has been set\")\n    except Exception as error:\n        messagebox.showerror(\n            \"Failed to set logging\", f\"Failed to set logging with exception: {error}\"\n        )\n</code></pre>"},{"location":"api/stt/","title":"STT","text":""},{"location":"api/stt/#voicekeyboard.stt","title":"<code>voicekeyboard.stt</code>","text":""},{"location":"api/stt/#voicekeyboard.stt.SpeechConverter","title":"<code>SpeechConverter</code>","text":"<p>Coordinates VAD + Whisper transcription and audio streaming.</p> Source code in <code>voicekeyboard\\stt.py</code> <pre><code>class SpeechConverter:\n    \"\"\"Coordinates VAD + Whisper transcription and audio streaming.\"\"\"\n\n    def __init_dry_run_flag(self) -&gt; bool:\n        \"\"\"Return True when VOICEKB_DRYRUN indicates a dry run (skip models).\"\"\"\n        return os.getenv(\"VOICEKB_DRYRUN\", \"0\") in (\"1\", \"true\", \"True\")\n\n    def _update_label(self, text: str) -&gt; None:\n        \"\"\"Emit a label change signal on the UI thread, if available.\"\"\"\n        try:\n            from .window import labelUpdater  # local import to avoid hard dep\n\n            labelUpdater.textChanged.emit(text)\n        except Exception:\n            # UI not available; ignore label updates\n            logging.debug(\"Label update skipped (UI not initialized)\")\n\n    def __init__(self):\n        \"\"\"Initialize state; heavy model loads happen lazily when needed.\n\n        This avoids importing or downloading large ML dependencies during tests\n        or when running in environments without GPU/CT2 installed. When\n        ``VOICEKB_DRYRUN`` is set, models are never loaded.\n        \"\"\"\n        try:\n            self.dry_run: bool = self.__init_dry_run_flag()\n            self.stream: Optional[Any] = None\n            self.streamThread: Optional[threading.Thread] = None\n            self.transcriptionThread: Optional[threading.Thread] = None\n            self.model: Optional[Any] = None\n            self.vadModel: Optional[Any] = None\n            # default VAD is a no-op until models are ensured\n            self.get_speech_timestamps: Callable[..., List[Dict[str, int]]] = (\n                lambda audio, *_args, **_kwargs: []\n            )\n            self._update_label(\"STT startup\\nLoading up settings\")\n            logging.debug(\"Setting audio chunk sizes\")\n            settings.audioChunkSize = int(settings.audioSampleRate * settings.audioChunkDuration)\n            settings.audioChunkOverlapSize = int(\n                settings.audioSampleRate * settings.audioChunkOverlapDuration\n            )\n            self._update_label(\"STT startup\\nSetting up audio queue\")\n            logging.debug(\"Starting audio queue\")\n            self.audioQueue: Queue = Queue()\n            logging.debug(\"Queue started\")\n            self._update_label(\"Ready!\")\n        except Exception as error:\n            self._update_label(\"Failed to start STT!\\nPlease check logs\")\n            logging.error(f\"Failed to initialize speech converter: {error}\")\n        else:\n            logging.info(\"Initialized speech converter\")\n\n    def _ensure_models_loaded(self) -&gt; None:\n        \"\"\"Lazy-load VAD and Whisper models if not in dry-run mode.\"\"\"\n        if self.dry_run:\n            return\n        if self.model is not None and self.vadModel is not None:\n            return\n        try:\n            self._update_label(\"STT startup\\nLoading models\")\n            logging.debug(\"Loading speech-to-text and VAD models lazily\")\n            # Import heavy deps only when needed\n            import torch\n            from faster_whisper import WhisperModel\n\n            self.model = WhisperModel(\n                model_size_or_path=settings.whisperModel,\n                device=settings.whisperDevice,\n                compute_type=settings.whisperComputeType,\n                cpu_threads=settings.whisperCpuThreads,\n                num_workers=settings.whisperNumWorkers,\n            )\n            self.vadModel, utils = torch.hub.load(\n                repo_or_dir=\"snakers4/silero-vad\",\n                model=\"silero_vad\",\n                force_reload=settings.vadForceRedownload,\n            )\n            (self.get_speech_timestamps, _, _, _, _) = utils\n            logging.debug(\"Models loaded\")\n        except Exception as e:\n            logging.error(f\"Failed to load models: {e}\")\n            # Keep placeholders to allow app to continue running\n            self.model = None\n            self.vadModel = None\n            self.get_speech_timestamps = lambda audio, *_a, **_k: []\n\n    def audioCallback(self, indata, frames, time_info, status):\n        \"\"\"Audio callback for sounddevice, pushing mono samples into the queue.\"\"\"\n        if indata.ndim &gt; 1:\n            mono_audio = numpy.mean(indata, axis=1)\n        else:\n            mono_audio = indata\n\n        self.audioQueue.put(mono_audio.copy())\n\n    def processAudioStream(self) -&gt; None:\n        \"\"\"Consume audio, detect voice segments, and transcribe when possible.\n\n        This loop keeps a sliding buffer and runs VAD to find voiced segments.\n        For each segment, it invokes the Whisper model to obtain text.\n        The loop terminates when ``_process_flag`` is cleared.\n        \"\"\"\n        audio_buffer = []\n        sample_rate = settings.audioSampleRate\n        # Process small windows to improve responsiveness and allow tests to feed short buffers\n        min_audio_window = max(160, int(sample_rate * 0.02))  # ~20ms at 16kHz\n\n        # Use a mutable flag set in start()/stop()\n        if not hasattr(self, \"_process_flag\"):\n            self._process_flag = [True]\n        while self._process_flag[0]:\n            try:\n                chunk = self.audioQueue.get(timeout=1)\n                audio_buffer.append(chunk)\n                audio_data = numpy.concatenate(audio_buffer, axis=0)\n                if len(audio_data) &lt; min_audio_window:\n                    continue\n                # Ensure heavy models are loaded if needed\n                if not self.dry_run and (self.model is None or self.vadModel is None):\n                    self._ensure_models_loaded()\n                speech_timestamps = self.get_speech_timestamps(\n                    audio_data, self.vadModel, sampling_rate=sample_rate\n                )\n                if speech_timestamps and self.model:\n                    for segment in speech_timestamps:\n                        start = segment[\"start\"]\n                        end = segment[\"end\"]\n                        voiced_audio = audio_data[start:end]\n                        voiced_audio = voiced_audio.astype(numpy.float32)\n                        segments, info = self.model.transcribe(\n                            voiced_audio,\n                            language=settings.whisperLanguage,\n                            vad_filter=False,\n                            word_timestamps=False,\n                        )\n                        text = \" \".join([seg.text for seg in segments])\n                        if text:\n                            logging.info(f\"Typing: {text}\")\n                audio_buffer = []\n            except Exception as e:\n                logging.error(f\"Error during real-time transcription: {e}\")\n                continue\n\n    def _run_audio_stream(self, record_flag: List[bool]) -&gt; None:\n        \"\"\"Maintain a persistent audio input stream while ``record_flag`` is True.\"\"\"\n        # Import here to avoid dependency at module import time\n        import sounddevice\n\n        with sounddevice.InputStream(\n            callback=self.audioCallback,\n            channels=settings.audioChannels,\n            samplerate=settings.audioSampleRate,\n        ) as stream:\n            self.stream = stream\n            while record_flag[0]:\n                time.sleep(0.1)\n\n    def start(self) -&gt; None:\n        \"\"\"Start audio capture and processing threads.\"\"\"\n        self._update_label(\"Recording/Processing...\")\n        logging.info(\"Started recording\")\n\n        self.transcriptionThread = threading.Thread(target=self.processAudioStream, daemon=True)\n        self.transcriptionThread.start()\n\n        self._record_flag = [True]\n        self._process_flag = [True]\n        self.streamThread = threading.Thread(\n            target=self._run_audio_stream, args=(self._record_flag,), daemon=True\n        )\n        self.streamThread.start()\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop audio capture and processing threads and clean up resources.\"\"\"\n        logging.info(\"Stopping STT system\")\n        if hasattr(self, \"_record_flag\"):\n            self._record_flag[0] = False\n        if hasattr(self, \"_process_flag\"):\n            self._process_flag[0] = False\n\n        if self.stream:\n            try:\n                self.stream.stop()\n                self.stream.close()\n                logging.info(\"Audio stream closed\")\n            except Exception as e:\n                logging.warning(f\"Failed to stop audio stream: {e}\")\n            self.stream = None\n\n        if self.streamThread and self.streamThread.is_alive():\n            self.streamThread.join(timeout=2)\n            logging.info(\"Audio thread joined\")\n            self.streamThread = None\n\n        if self.transcriptionThread and self.transcriptionThread.is_alive():\n            self.transcriptionThread.join(timeout=2)\n            logging.info(\"Transcription thread joined\")\n            self.transcriptionThread = None\n\n        self._update_label(\"Stopped recording..\")\n</code></pre>"},{"location":"api/stt/#voicekeyboard.stt.SpeechConverter.__init__","title":"<code>__init__()</code>","text":"<p>Initialize state; heavy model loads happen lazily when needed.</p> <p>This avoids importing or downloading large ML dependencies during tests or when running in environments without GPU/CT2 installed. When <code>VOICEKB_DRYRUN</code> is set, models are never loaded.</p> Source code in <code>voicekeyboard\\stt.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize state; heavy model loads happen lazily when needed.\n\n    This avoids importing or downloading large ML dependencies during tests\n    or when running in environments without GPU/CT2 installed. When\n    ``VOICEKB_DRYRUN`` is set, models are never loaded.\n    \"\"\"\n    try:\n        self.dry_run: bool = self.__init_dry_run_flag()\n        self.stream: Optional[Any] = None\n        self.streamThread: Optional[threading.Thread] = None\n        self.transcriptionThread: Optional[threading.Thread] = None\n        self.model: Optional[Any] = None\n        self.vadModel: Optional[Any] = None\n        # default VAD is a no-op until models are ensured\n        self.get_speech_timestamps: Callable[..., List[Dict[str, int]]] = (\n            lambda audio, *_args, **_kwargs: []\n        )\n        self._update_label(\"STT startup\\nLoading up settings\")\n        logging.debug(\"Setting audio chunk sizes\")\n        settings.audioChunkSize = int(settings.audioSampleRate * settings.audioChunkDuration)\n        settings.audioChunkOverlapSize = int(\n            settings.audioSampleRate * settings.audioChunkOverlapDuration\n        )\n        self._update_label(\"STT startup\\nSetting up audio queue\")\n        logging.debug(\"Starting audio queue\")\n        self.audioQueue: Queue = Queue()\n        logging.debug(\"Queue started\")\n        self._update_label(\"Ready!\")\n    except Exception as error:\n        self._update_label(\"Failed to start STT!\\nPlease check logs\")\n        logging.error(f\"Failed to initialize speech converter: {error}\")\n    else:\n        logging.info(\"Initialized speech converter\")\n</code></pre>"},{"location":"api/stt/#voicekeyboard.stt.SpeechConverter.__init_dry_run_flag","title":"<code>__init_dry_run_flag()</code>","text":"<p>Return True when VOICEKB_DRYRUN indicates a dry run (skip models).</p> Source code in <code>voicekeyboard\\stt.py</code> <pre><code>def __init_dry_run_flag(self) -&gt; bool:\n    \"\"\"Return True when VOICEKB_DRYRUN indicates a dry run (skip models).\"\"\"\n    return os.getenv(\"VOICEKB_DRYRUN\", \"0\") in (\"1\", \"true\", \"True\")\n</code></pre>"},{"location":"api/stt/#voicekeyboard.stt.SpeechConverter._ensure_models_loaded","title":"<code>_ensure_models_loaded()</code>","text":"<p>Lazy-load VAD and Whisper models if not in dry-run mode.</p> Source code in <code>voicekeyboard\\stt.py</code> <pre><code>def _ensure_models_loaded(self) -&gt; None:\n    \"\"\"Lazy-load VAD and Whisper models if not in dry-run mode.\"\"\"\n    if self.dry_run:\n        return\n    if self.model is not None and self.vadModel is not None:\n        return\n    try:\n        self._update_label(\"STT startup\\nLoading models\")\n        logging.debug(\"Loading speech-to-text and VAD models lazily\")\n        # Import heavy deps only when needed\n        import torch\n        from faster_whisper import WhisperModel\n\n        self.model = WhisperModel(\n            model_size_or_path=settings.whisperModel,\n            device=settings.whisperDevice,\n            compute_type=settings.whisperComputeType,\n            cpu_threads=settings.whisperCpuThreads,\n            num_workers=settings.whisperNumWorkers,\n        )\n        self.vadModel, utils = torch.hub.load(\n            repo_or_dir=\"snakers4/silero-vad\",\n            model=\"silero_vad\",\n            force_reload=settings.vadForceRedownload,\n        )\n        (self.get_speech_timestamps, _, _, _, _) = utils\n        logging.debug(\"Models loaded\")\n    except Exception as e:\n        logging.error(f\"Failed to load models: {e}\")\n        # Keep placeholders to allow app to continue running\n        self.model = None\n        self.vadModel = None\n        self.get_speech_timestamps = lambda audio, *_a, **_k: []\n</code></pre>"},{"location":"api/stt/#voicekeyboard.stt.SpeechConverter._run_audio_stream","title":"<code>_run_audio_stream(record_flag)</code>","text":"<p>Maintain a persistent audio input stream while <code>record_flag</code> is True.</p> Source code in <code>voicekeyboard\\stt.py</code> <pre><code>def _run_audio_stream(self, record_flag: List[bool]) -&gt; None:\n    \"\"\"Maintain a persistent audio input stream while ``record_flag`` is True.\"\"\"\n    # Import here to avoid dependency at module import time\n    import sounddevice\n\n    with sounddevice.InputStream(\n        callback=self.audioCallback,\n        channels=settings.audioChannels,\n        samplerate=settings.audioSampleRate,\n    ) as stream:\n        self.stream = stream\n        while record_flag[0]:\n            time.sleep(0.1)\n</code></pre>"},{"location":"api/stt/#voicekeyboard.stt.SpeechConverter._update_label","title":"<code>_update_label(text)</code>","text":"<p>Emit a label change signal on the UI thread, if available.</p> Source code in <code>voicekeyboard\\stt.py</code> <pre><code>def _update_label(self, text: str) -&gt; None:\n    \"\"\"Emit a label change signal on the UI thread, if available.\"\"\"\n    try:\n        from .window import labelUpdater  # local import to avoid hard dep\n\n        labelUpdater.textChanged.emit(text)\n    except Exception:\n        # UI not available; ignore label updates\n        logging.debug(\"Label update skipped (UI not initialized)\")\n</code></pre>"},{"location":"api/stt/#voicekeyboard.stt.SpeechConverter.audioCallback","title":"<code>audioCallback(indata, frames, time_info, status)</code>","text":"<p>Audio callback for sounddevice, pushing mono samples into the queue.</p> Source code in <code>voicekeyboard\\stt.py</code> <pre><code>def audioCallback(self, indata, frames, time_info, status):\n    \"\"\"Audio callback for sounddevice, pushing mono samples into the queue.\"\"\"\n    if indata.ndim &gt; 1:\n        mono_audio = numpy.mean(indata, axis=1)\n    else:\n        mono_audio = indata\n\n    self.audioQueue.put(mono_audio.copy())\n</code></pre>"},{"location":"api/stt/#voicekeyboard.stt.SpeechConverter.processAudioStream","title":"<code>processAudioStream()</code>","text":"<p>Consume audio, detect voice segments, and transcribe when possible.</p> <p>This loop keeps a sliding buffer and runs VAD to find voiced segments. For each segment, it invokes the Whisper model to obtain text. The loop terminates when <code>_process_flag</code> is cleared.</p> Source code in <code>voicekeyboard\\stt.py</code> <pre><code>def processAudioStream(self) -&gt; None:\n    \"\"\"Consume audio, detect voice segments, and transcribe when possible.\n\n    This loop keeps a sliding buffer and runs VAD to find voiced segments.\n    For each segment, it invokes the Whisper model to obtain text.\n    The loop terminates when ``_process_flag`` is cleared.\n    \"\"\"\n    audio_buffer = []\n    sample_rate = settings.audioSampleRate\n    # Process small windows to improve responsiveness and allow tests to feed short buffers\n    min_audio_window = max(160, int(sample_rate * 0.02))  # ~20ms at 16kHz\n\n    # Use a mutable flag set in start()/stop()\n    if not hasattr(self, \"_process_flag\"):\n        self._process_flag = [True]\n    while self._process_flag[0]:\n        try:\n            chunk = self.audioQueue.get(timeout=1)\n            audio_buffer.append(chunk)\n            audio_data = numpy.concatenate(audio_buffer, axis=0)\n            if len(audio_data) &lt; min_audio_window:\n                continue\n            # Ensure heavy models are loaded if needed\n            if not self.dry_run and (self.model is None or self.vadModel is None):\n                self._ensure_models_loaded()\n            speech_timestamps = self.get_speech_timestamps(\n                audio_data, self.vadModel, sampling_rate=sample_rate\n            )\n            if speech_timestamps and self.model:\n                for segment in speech_timestamps:\n                    start = segment[\"start\"]\n                    end = segment[\"end\"]\n                    voiced_audio = audio_data[start:end]\n                    voiced_audio = voiced_audio.astype(numpy.float32)\n                    segments, info = self.model.transcribe(\n                        voiced_audio,\n                        language=settings.whisperLanguage,\n                        vad_filter=False,\n                        word_timestamps=False,\n                    )\n                    text = \" \".join([seg.text for seg in segments])\n                    if text:\n                        logging.info(f\"Typing: {text}\")\n            audio_buffer = []\n        except Exception as e:\n            logging.error(f\"Error during real-time transcription: {e}\")\n            continue\n</code></pre>"},{"location":"api/stt/#voicekeyboard.stt.SpeechConverter.start","title":"<code>start()</code>","text":"<p>Start audio capture and processing threads.</p> Source code in <code>voicekeyboard\\stt.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start audio capture and processing threads.\"\"\"\n    self._update_label(\"Recording/Processing...\")\n    logging.info(\"Started recording\")\n\n    self.transcriptionThread = threading.Thread(target=self.processAudioStream, daemon=True)\n    self.transcriptionThread.start()\n\n    self._record_flag = [True]\n    self._process_flag = [True]\n    self.streamThread = threading.Thread(\n        target=self._run_audio_stream, args=(self._record_flag,), daemon=True\n    )\n    self.streamThread.start()\n</code></pre>"},{"location":"api/stt/#voicekeyboard.stt.SpeechConverter.stop","title":"<code>stop()</code>","text":"<p>Stop audio capture and processing threads and clean up resources.</p> Source code in <code>voicekeyboard\\stt.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop audio capture and processing threads and clean up resources.\"\"\"\n    logging.info(\"Stopping STT system\")\n    if hasattr(self, \"_record_flag\"):\n        self._record_flag[0] = False\n    if hasattr(self, \"_process_flag\"):\n        self._process_flag[0] = False\n\n    if self.stream:\n        try:\n            self.stream.stop()\n            self.stream.close()\n            logging.info(\"Audio stream closed\")\n        except Exception as e:\n            logging.warning(f\"Failed to stop audio stream: {e}\")\n        self.stream = None\n\n    if self.streamThread and self.streamThread.is_alive():\n        self.streamThread.join(timeout=2)\n        logging.info(\"Audio thread joined\")\n        self.streamThread = None\n\n    if self.transcriptionThread and self.transcriptionThread.is_alive():\n        self.transcriptionThread.join(timeout=2)\n        logging.info(\"Transcription thread joined\")\n        self.transcriptionThread = None\n\n    self._update_label(\"Stopped recording..\")\n</code></pre>"},{"location":"api/tray/","title":"Tray","text":""},{"location":"api/tray/#voicekeyboard.tray","title":"<code>voicekeyboard.tray</code>","text":""},{"location":"api/tray/#voicekeyboard.tray.ImageWrapper","title":"<code>ImageWrapper</code>","text":"<p>Create a simple placeholder tray icon image using Pillow.</p> Source code in <code>voicekeyboard\\tray.py</code> <pre><code>class ImageWrapper:\n    \"\"\"Create a simple placeholder tray icon image using Pillow.\"\"\"\n\n    @staticmethod\n    def createImage():\n        try:\n            width: int = 64\n            height: int = 64\n            mode: str = \"RGB\"\n            image = Image.new(mode, (width, height), color=(255, 255, 255))\n            draw = ImageDraw.Draw(image)\n            draw.rectangle((0, 0, width, height), fill=(0, 128, 255))\n            draw.ellipse((16, 16, width - 16, height - 16), fill=(255, 255, 0))\n        except Exception as error:\n            logging.error(f\"Failed to create image: {error}\")\n        else:\n            logging.debug(\"Created image\")\n            return image\n</code></pre>"},{"location":"api/tray/#voicekeyboard.tray.TrayIconManager","title":"<code>TrayIconManager</code>","text":"<p>Manage the pystray icon lifecycle and menu wiring.</p> Source code in <code>voicekeyboard\\tray.py</code> <pre><code>class TrayIconManager:\n    \"\"\"Manage the pystray icon lifecycle and menu wiring.\"\"\"\n\n    icon = None\n\n    @staticmethod\n    def onClick(icon, item):\n        \"\"\"Generic click logger for quick diagnostics.\"\"\"\n        logging.info(f\"Menu item '{item}' clicked!\")\n\n    @staticmethod\n    def setup(icon):\n        \"\"\"Make icon visible once the tray loop starts.\"\"\"\n        icon.visible = True\n\n    @staticmethod\n    def menuInit(open_settings_cb, open_preferences_cb, restart_cb, exit_cb, toggle_window_cb=None):\n        \"\"\"Build the tray menu with injected callbacks for actions.\"\"\"\n        if toggle_window_cb is None:\n\n            def toggle_window_cb(*_args, **_kwargs):\n                return None\n\n        return Menu(\n            MenuItem(text=settings.labelTrayMenuTitle, action=lambda *_: None),\n            MenuItem(text=settings.labelTrayMenuDivider1, action=lambda *_: None, enabled=False),\n            MenuItem(\n                text=settings.labelTrayMenuSettings,\n                action=Menu(\n                    MenuItem(text=settings.labelTrayMenuToggleWindow, action=toggle_window_cb),\n                    MenuItem(text=settings.labelTrayMenuOpenSettings, action=open_settings_cb),\n                    MenuItem(text=settings.labelTrayMenuEditHotkeys, action=open_preferences_cb),\n                ),\n            ),\n            MenuItem(text=settings.labelTrayMenuRestart, action=restart_cb),\n            MenuItem(text=settings.labelTrayMenuExit, action=exit_cb),\n        )\n\n    @staticmethod\n    def run(open_settings_cb, open_preferences_cb, restart_cb, exit_cb, toggle_window_cb):\n        \"\"\"Run the tray loop in a blocking manner (to be called on a thread).\"\"\"\n        menu = TrayIconManager.menuInit(\n            open_settings_cb,\n            open_preferences_cb,\n            restart_cb,\n            exit_cb,\n            toggle_window_cb,\n        )\n        TrayIconManager.icon = Icon(\n            settings.labelTrayIconTitle,\n            ImageWrapper.createImage(),\n            settings.labelTrayIconName,\n            menu,\n        )\n        TrayIconManager.icon.run(setup=TrayIconManager.setup)\n\n    @staticmethod\n    def start(open_settings_cb, open_preferences_cb, restart_cb, exit_cb, toggle_window_cb):\n        \"\"\"Spawn a daemon thread to start the tray icon if enabled in settings.\"\"\"\n        if not settings.trayIconShow:\n            return None\n        trayThread = threading.Thread(\n            target=TrayIconManager.run,\n            args=(open_settings_cb, open_preferences_cb, restart_cb, exit_cb, toggle_window_cb),\n            daemon=settings.trayIconDaemon,\n        )\n        trayThread.start()\n\n    @staticmethod\n    def stop():\n        \"\"\"Stop the tray icon if running and swallow errors safely.\"\"\"\n        try:\n            logging.debug(\"Stopping tray icon\")\n            if TrayIconManager.icon:\n                TrayIconManager.icon.stop()\n        except Exception as error:\n            logging.error(f\"Failed to stop with error: {error}\")\n        else:\n            logging.debug(\"Stopped tray icon\")\n</code></pre>"},{"location":"api/tray/#voicekeyboard.tray.TrayIconManager.menuInit","title":"<code>menuInit(open_settings_cb, open_preferences_cb, restart_cb, exit_cb, toggle_window_cb=None)</code>  <code>staticmethod</code>","text":"<p>Build the tray menu with injected callbacks for actions.</p> Source code in <code>voicekeyboard\\tray.py</code> <pre><code>@staticmethod\ndef menuInit(open_settings_cb, open_preferences_cb, restart_cb, exit_cb, toggle_window_cb=None):\n    \"\"\"Build the tray menu with injected callbacks for actions.\"\"\"\n    if toggle_window_cb is None:\n\n        def toggle_window_cb(*_args, **_kwargs):\n            return None\n\n    return Menu(\n        MenuItem(text=settings.labelTrayMenuTitle, action=lambda *_: None),\n        MenuItem(text=settings.labelTrayMenuDivider1, action=lambda *_: None, enabled=False),\n        MenuItem(\n            text=settings.labelTrayMenuSettings,\n            action=Menu(\n                MenuItem(text=settings.labelTrayMenuToggleWindow, action=toggle_window_cb),\n                MenuItem(text=settings.labelTrayMenuOpenSettings, action=open_settings_cb),\n                MenuItem(text=settings.labelTrayMenuEditHotkeys, action=open_preferences_cb),\n            ),\n        ),\n        MenuItem(text=settings.labelTrayMenuRestart, action=restart_cb),\n        MenuItem(text=settings.labelTrayMenuExit, action=exit_cb),\n    )\n</code></pre>"},{"location":"api/tray/#voicekeyboard.tray.TrayIconManager.onClick","title":"<code>onClick(icon, item)</code>  <code>staticmethod</code>","text":"<p>Generic click logger for quick diagnostics.</p> Source code in <code>voicekeyboard\\tray.py</code> <pre><code>@staticmethod\ndef onClick(icon, item):\n    \"\"\"Generic click logger for quick diagnostics.\"\"\"\n    logging.info(f\"Menu item '{item}' clicked!\")\n</code></pre>"},{"location":"api/tray/#voicekeyboard.tray.TrayIconManager.run","title":"<code>run(open_settings_cb, open_preferences_cb, restart_cb, exit_cb, toggle_window_cb)</code>  <code>staticmethod</code>","text":"<p>Run the tray loop in a blocking manner (to be called on a thread).</p> Source code in <code>voicekeyboard\\tray.py</code> <pre><code>@staticmethod\ndef run(open_settings_cb, open_preferences_cb, restart_cb, exit_cb, toggle_window_cb):\n    \"\"\"Run the tray loop in a blocking manner (to be called on a thread).\"\"\"\n    menu = TrayIconManager.menuInit(\n        open_settings_cb,\n        open_preferences_cb,\n        restart_cb,\n        exit_cb,\n        toggle_window_cb,\n    )\n    TrayIconManager.icon = Icon(\n        settings.labelTrayIconTitle,\n        ImageWrapper.createImage(),\n        settings.labelTrayIconName,\n        menu,\n    )\n    TrayIconManager.icon.run(setup=TrayIconManager.setup)\n</code></pre>"},{"location":"api/tray/#voicekeyboard.tray.TrayIconManager.setup","title":"<code>setup(icon)</code>  <code>staticmethod</code>","text":"<p>Make icon visible once the tray loop starts.</p> Source code in <code>voicekeyboard\\tray.py</code> <pre><code>@staticmethod\ndef setup(icon):\n    \"\"\"Make icon visible once the tray loop starts.\"\"\"\n    icon.visible = True\n</code></pre>"},{"location":"api/tray/#voicekeyboard.tray.TrayIconManager.start","title":"<code>start(open_settings_cb, open_preferences_cb, restart_cb, exit_cb, toggle_window_cb)</code>  <code>staticmethod</code>","text":"<p>Spawn a daemon thread to start the tray icon if enabled in settings.</p> Source code in <code>voicekeyboard\\tray.py</code> <pre><code>@staticmethod\ndef start(open_settings_cb, open_preferences_cb, restart_cb, exit_cb, toggle_window_cb):\n    \"\"\"Spawn a daemon thread to start the tray icon if enabled in settings.\"\"\"\n    if not settings.trayIconShow:\n        return None\n    trayThread = threading.Thread(\n        target=TrayIconManager.run,\n        args=(open_settings_cb, open_preferences_cb, restart_cb, exit_cb, toggle_window_cb),\n        daemon=settings.trayIconDaemon,\n    )\n    trayThread.start()\n</code></pre>"},{"location":"api/tray/#voicekeyboard.tray.TrayIconManager.stop","title":"<code>stop()</code>  <code>staticmethod</code>","text":"<p>Stop the tray icon if running and swallow errors safely.</p> Source code in <code>voicekeyboard\\tray.py</code> <pre><code>@staticmethod\ndef stop():\n    \"\"\"Stop the tray icon if running and swallow errors safely.\"\"\"\n    try:\n        logging.debug(\"Stopping tray icon\")\n        if TrayIconManager.icon:\n            TrayIconManager.icon.stop()\n    except Exception as error:\n        logging.error(f\"Failed to stop with error: {error}\")\n    else:\n        logging.debug(\"Stopped tray icon\")\n</code></pre>"},{"location":"api/window/","title":"Window","text":""},{"location":"api/window/#voicekeyboard.window","title":"<code>voicekeyboard.window</code>","text":""},{"location":"api/window/#voicekeyboard.window.LabelUpdater","title":"<code>LabelUpdater</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Signal-based helper to update the UI label from worker threads.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>class LabelUpdater(QtCore.QObject):\n    \"\"\"Signal-based helper to update the UI label from worker threads.\"\"\"\n\n    textChanged = QtCore.pyqtSignal(str)\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.UiInvoker","title":"<code>UiInvoker</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Lightweight invoker to run arbitrary callables in the Qt UI thread.</p> <p>Use :func:<code>invoke_in_ui</code> to schedule a function from any thread. The callable will be executed on the Qt thread as soon as the event loop processes the signal.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>class UiInvoker(QtCore.QObject):\n    \"\"\"Lightweight invoker to run arbitrary callables in the Qt UI thread.\n\n    Use :func:`invoke_in_ui` to schedule a function from any thread. The callable\n    will be executed on the Qt thread as soon as the event loop processes the signal.\n    \"\"\"\n\n    callRequested = QtCore.pyqtSignal(object)\n\n    def __init__(self):\n        super().__init__()\n        self.callRequested.connect(self._run)\n\n    def _run(self, fn):\n        try:\n            fn()\n        except Exception as e:\n            import logging\n\n            logging.error(f\"UiInvoker callable error: {e}\")\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager","title":"<code>WindowManager</code>","text":"<p>               Bases: <code>QMainWindow</code></p> <p>Main application window (frameless label overlay) with optional blur.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>class WindowManager(QMainWindow):\n    \"\"\"Main application window (frameless label overlay) with optional blur.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        self.setWindowFlags(self.__initWindowFlagsBuilder())\n        self.setFixedSize(self.__initWindowSizeBuilder())\n        self.setStyleSheet(self.__initWindowStylesBuilder())\n        self.setWindowTitle(settings.windowTitle)\n        self.__initSetWindowOpacity()\n        self.__initRestoreWindow()\n\n        if settings.windowDraggable:\n            self._isDragging: bool = False\n            self._dragStartPosition: QPoint = QtCore.QPoint()\n\n        self.__initWindowMainLabel()\n        self.installEventFilter(self)\n        self.__initWindowUpdater()\n\n    def __initWindowMainLabel(self):\n        \"\"\"Create and attach the main text label, set default style and binding.\"\"\"\n        global windowLabel\n        windowLabel = QLabel(settings.labelWindowWelcome, self)\n        windowLabel.setAlignment(QtCore.Qt.AlignmentFlag.AlignLeft)\n        windowLabel.setGeometry(2, 2, 200, 50)\n        windowLabel.setStyleSheet(self.__initWindowLabelStyleBuilder())\n        labelUpdater.textChanged.connect(windowLabel.setText)\n\n    def __initWindowLabelStyleBuilder(self):\n        return \"\"\"\n            background-color: transparent;\n            border: none;\n        \"\"\"\n\n    def __initWindowUpdater(self):\n        \"\"\"Enable periodic repaint when background blur is active.\"\"\"\n        if settings.windowBlurBackgroundEnabled:\n            self.timer: QTimer = QTimer(self)\n            self.timer.timeout.connect(self.update)\n            self.timer.start(settings.windowBlurBackgroundPeriod)\n\n    def __initRestoreWindow(self):\n        \"\"\"Move window to last known position if restore is enabled.\"\"\"\n        if settings.windowPosRestoreOnStartup:\n            x: int = settings.windowPosX\n            y: int = settings.windowPosY\n            logging.debug(f\"Restoring window position to {x}, {y}\")\n            self.move(x, y)\n\n    def __initSetWindowOpacity(self):\n        \"\"\"Apply configured window opacity when enabled.\"\"\"\n        if settings.windowOpacityEnabled:\n            self.setWindowOpacity(settings.windowOpacity)\n\n    def __initWindowSizeBuilder(self):\n        \"\"\"Return the desired fixed window size.\"\"\"\n        return QSize(settings.windowWidth, settings.windowHeight)\n\n    def __initWindowBorderBuilder(self):\n        \"\"\"Compose CSS border style or 'none' when disabled.\"\"\"\n        if settings.windowBorderEnabled:\n            width = settings.windowBorderWidthPx\n            btype = settings.windowBorderType\n            color = settings.windowBorderColor\n            return f\"{width}px {btype} {color}\"\n        return \"none\"\n\n    def __initWindowStylesBuilder(self):\n        \"\"\"Compose the complete stylesheet for the window.\"\"\"\n        return f\"\"\"\n            background-color: {settings.windowBackgroundColor};\n            border: {self.__initWindowBorderBuilder()};\n            border-radius: 1px;\n            color: {settings.windowTextColor};\n            font-size: {settings.windowTextSizePx}px;\n            font-family: {settings.windowTextFontType};\n            font-weight: {settings.windowTextFontWeight};\n            \"\"\"\n\n    def __initWindowFlagsBuilder(self):\n        \"\"\"Build the Qt window flags according to settings.\"\"\"\n        windowFlags = Qt.WindowType.X11BypassWindowManagerHint\n        if settings.windowKeepOnTop:\n            windowFlags |= Qt.WindowType.WindowStaysOnTopHint\n        if settings.windowFrameless:\n            windowFlags |= Qt.WindowType.FramelessWindowHint\n        return windowFlags\n\n    def applyBlur(self, pixmap):\n        \"\"\"Apply Gaussian blur to the captured background pixmap.\"\"\"\n        image = pixmap.toImage()\n        if image.format() != QImage.Format.Format_ARGB32:\n            image = image.convertToFormat(QImage.Format.Format_ARGB32)\n\n        width, height = image.width(), image.height()\n        imageData: bytes = image.bits().asstring(width * height * 4)\n        imageMode: str = \"RGBA\"\n        pilImage = Image.frombytes(imageMode, (width, height), imageData)\n        blurredImage = pilImage.filter(\n            ImageFilter.GaussianBlur(settings.windowBlurBackgroundStrength)\n        )\n        blurredImageData: bytes = blurredImage.tobytes()\n        qimage: QImage = QImage(blurredImageData, width, height, QImage.Format.Format_ARGB32)\n        return QPixmap.fromImage(qimage)\n\n    def paintEvent(self, event):\n        if settings.windowBlurBackgroundEnabled:\n            painter: QPainter = QPainter(self)\n            painter.setRenderHint(QPainter.RenderHint.Antialiasing)\n            painter.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform)\n            screen = QApplication.primaryScreen()\n            if screen is None:\n                return\n            screenshot: QPixmap = screen.grabWindow(0)  # type: ignore[arg-type]\n            pixmap: QPixmap = screenshot.copy(self.geometry())\n            blurredPixmap: QPixmap = self.applyBlur(pixmap)\n            painter.drawPixmap(0, 0, blurredPixmap)\n            painter.end()\n\n    def eventFilter(self, source, event):\n        \"\"\"Forward mouse press events so the window can be dragged when enabled.\"\"\"\n        if event.type() == QtCore.QEvent.Type.MouseButtonPress:\n            self.mousePressEvent(event)\n            return True\n        return super().eventFilter(source, event)\n\n    def mousePressEvent(self, event):\n        \"\"\"Start drag when left mouse button is pressed on the window.\"\"\"\n        logging.debug(\"Detected mouse press event\")\n        if settings.windowDraggable:\n            if event.button() == QtCore.Qt.MouseButton.LeftButton:\n                self._isDragging = True\n                self._dragStartPosition = (\n                    event.globalPosition().toPoint() - self.frameGeometry().topLeft()\n                )\n                event.accept()\n\n    def mouseMoveEvent(self, event):\n        \"\"\"Update window position while dragging, optionally clamping to screen.\"\"\"\n        if settings.windowDraggable and self._isDragging:\n            newPosition = event.globalPosition().toPoint() - self._dragStartPosition\n            screen = QApplication.primaryScreen()\n            if screen is None:\n                return\n            screenGeometry: QRect = screen.availableGeometry()\n            if settings.windowClipToScreenBorder:\n                newPosition.setX(\n                    max(\n                        screenGeometry.left(),\n                        min(newPosition.x(), screenGeometry.right() - self.width()),\n                    )\n                )\n                newPosition.setY(\n                    max(\n                        screenGeometry.top(),\n                        min(newPosition.y(), screenGeometry.bottom() - self.height()),\n                    )\n                )\n                self.move(newPosition)\n            else:\n                self.move(event.globalPosition().toPoint() - self._dragStartPosition)\n            event.accept()\n\n    def mouseReleaseEvent(self, event):\n        \"\"\"Persist last window position upon releasing the mouse button.\"\"\"\n        logging.debug(\"Detected mouse release event\")\n        if settings.windowDraggable and event.button() == QtCore.Qt.MouseButton.LeftButton:\n            self._isDragging = False\n            windowPosition: QPoint = self.pos()\n            settings.windowPosX = windowPosition.x()\n            settings.windowPosY = windowPosition.y()\n            event.accept()\n\n    @staticmethod\n    def run():\n        \"\"\"Create Qt application and start the window in the UI thread.\"\"\"\n        global window\n        global uiInvoker\n        application: QApplication = QApplication([])\n        uiInvoker = UiInvoker()\n        window = WindowManager()\n        if settings.windowShow:\n            window.show()\n\n        # Auto-close for CI smoke tests\n        try:\n            ms = int(os.getenv(\"VOICEKB_AUTOCLOSE_MS\", \"0\"))\n        except ValueError:\n            ms = 0\n        if ms &gt; 0:\n            QTimer.singleShot(ms, application.quit)\n\n        application.exec()\n\n    @staticmethod\n    def start():\n        \"\"\"Spawn a daemon thread to run the Qt UI when enabled in settings.\"\"\"\n        if not settings.windowShow:\n            return None\n        windowThread = threading.Thread(\n            target=WindowManager.run,\n            daemon=settings.windowDaemon,\n        )\n        windowThread.start()\n\n    @staticmethod\n    def wait_label():\n        \"\"\"Wait until the global label widget is created (used at startup).\"\"\"\n        global windowLabel\n        while True:\n            if windowLabel is not None:\n                return\n            time.sleep(0.1)\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.__initRestoreWindow","title":"<code>__initRestoreWindow()</code>","text":"<p>Move window to last known position if restore is enabled.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>def __initRestoreWindow(self):\n    \"\"\"Move window to last known position if restore is enabled.\"\"\"\n    if settings.windowPosRestoreOnStartup:\n        x: int = settings.windowPosX\n        y: int = settings.windowPosY\n        logging.debug(f\"Restoring window position to {x}, {y}\")\n        self.move(x, y)\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.__initSetWindowOpacity","title":"<code>__initSetWindowOpacity()</code>","text":"<p>Apply configured window opacity when enabled.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>def __initSetWindowOpacity(self):\n    \"\"\"Apply configured window opacity when enabled.\"\"\"\n    if settings.windowOpacityEnabled:\n        self.setWindowOpacity(settings.windowOpacity)\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.__initWindowBorderBuilder","title":"<code>__initWindowBorderBuilder()</code>","text":"<p>Compose CSS border style or 'none' when disabled.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>def __initWindowBorderBuilder(self):\n    \"\"\"Compose CSS border style or 'none' when disabled.\"\"\"\n    if settings.windowBorderEnabled:\n        width = settings.windowBorderWidthPx\n        btype = settings.windowBorderType\n        color = settings.windowBorderColor\n        return f\"{width}px {btype} {color}\"\n    return \"none\"\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.__initWindowFlagsBuilder","title":"<code>__initWindowFlagsBuilder()</code>","text":"<p>Build the Qt window flags according to settings.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>def __initWindowFlagsBuilder(self):\n    \"\"\"Build the Qt window flags according to settings.\"\"\"\n    windowFlags = Qt.WindowType.X11BypassWindowManagerHint\n    if settings.windowKeepOnTop:\n        windowFlags |= Qt.WindowType.WindowStaysOnTopHint\n    if settings.windowFrameless:\n        windowFlags |= Qt.WindowType.FramelessWindowHint\n    return windowFlags\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.__initWindowMainLabel","title":"<code>__initWindowMainLabel()</code>","text":"<p>Create and attach the main text label, set default style and binding.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>def __initWindowMainLabel(self):\n    \"\"\"Create and attach the main text label, set default style and binding.\"\"\"\n    global windowLabel\n    windowLabel = QLabel(settings.labelWindowWelcome, self)\n    windowLabel.setAlignment(QtCore.Qt.AlignmentFlag.AlignLeft)\n    windowLabel.setGeometry(2, 2, 200, 50)\n    windowLabel.setStyleSheet(self.__initWindowLabelStyleBuilder())\n    labelUpdater.textChanged.connect(windowLabel.setText)\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.__initWindowSizeBuilder","title":"<code>__initWindowSizeBuilder()</code>","text":"<p>Return the desired fixed window size.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>def __initWindowSizeBuilder(self):\n    \"\"\"Return the desired fixed window size.\"\"\"\n    return QSize(settings.windowWidth, settings.windowHeight)\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.__initWindowStylesBuilder","title":"<code>__initWindowStylesBuilder()</code>","text":"<p>Compose the complete stylesheet for the window.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>def __initWindowStylesBuilder(self):\n    \"\"\"Compose the complete stylesheet for the window.\"\"\"\n    return f\"\"\"\n        background-color: {settings.windowBackgroundColor};\n        border: {self.__initWindowBorderBuilder()};\n        border-radius: 1px;\n        color: {settings.windowTextColor};\n        font-size: {settings.windowTextSizePx}px;\n        font-family: {settings.windowTextFontType};\n        font-weight: {settings.windowTextFontWeight};\n        \"\"\"\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.__initWindowUpdater","title":"<code>__initWindowUpdater()</code>","text":"<p>Enable periodic repaint when background blur is active.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>def __initWindowUpdater(self):\n    \"\"\"Enable periodic repaint when background blur is active.\"\"\"\n    if settings.windowBlurBackgroundEnabled:\n        self.timer: QTimer = QTimer(self)\n        self.timer.timeout.connect(self.update)\n        self.timer.start(settings.windowBlurBackgroundPeriod)\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.applyBlur","title":"<code>applyBlur(pixmap)</code>","text":"<p>Apply Gaussian blur to the captured background pixmap.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>def applyBlur(self, pixmap):\n    \"\"\"Apply Gaussian blur to the captured background pixmap.\"\"\"\n    image = pixmap.toImage()\n    if image.format() != QImage.Format.Format_ARGB32:\n        image = image.convertToFormat(QImage.Format.Format_ARGB32)\n\n    width, height = image.width(), image.height()\n    imageData: bytes = image.bits().asstring(width * height * 4)\n    imageMode: str = \"RGBA\"\n    pilImage = Image.frombytes(imageMode, (width, height), imageData)\n    blurredImage = pilImage.filter(\n        ImageFilter.GaussianBlur(settings.windowBlurBackgroundStrength)\n    )\n    blurredImageData: bytes = blurredImage.tobytes()\n    qimage: QImage = QImage(blurredImageData, width, height, QImage.Format.Format_ARGB32)\n    return QPixmap.fromImage(qimage)\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.eventFilter","title":"<code>eventFilter(source, event)</code>","text":"<p>Forward mouse press events so the window can be dragged when enabled.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>def eventFilter(self, source, event):\n    \"\"\"Forward mouse press events so the window can be dragged when enabled.\"\"\"\n    if event.type() == QtCore.QEvent.Type.MouseButtonPress:\n        self.mousePressEvent(event)\n        return True\n    return super().eventFilter(source, event)\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.mouseMoveEvent","title":"<code>mouseMoveEvent(event)</code>","text":"<p>Update window position while dragging, optionally clamping to screen.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>def mouseMoveEvent(self, event):\n    \"\"\"Update window position while dragging, optionally clamping to screen.\"\"\"\n    if settings.windowDraggable and self._isDragging:\n        newPosition = event.globalPosition().toPoint() - self._dragStartPosition\n        screen = QApplication.primaryScreen()\n        if screen is None:\n            return\n        screenGeometry: QRect = screen.availableGeometry()\n        if settings.windowClipToScreenBorder:\n            newPosition.setX(\n                max(\n                    screenGeometry.left(),\n                    min(newPosition.x(), screenGeometry.right() - self.width()),\n                )\n            )\n            newPosition.setY(\n                max(\n                    screenGeometry.top(),\n                    min(newPosition.y(), screenGeometry.bottom() - self.height()),\n                )\n            )\n            self.move(newPosition)\n        else:\n            self.move(event.globalPosition().toPoint() - self._dragStartPosition)\n        event.accept()\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.mousePressEvent","title":"<code>mousePressEvent(event)</code>","text":"<p>Start drag when left mouse button is pressed on the window.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>def mousePressEvent(self, event):\n    \"\"\"Start drag when left mouse button is pressed on the window.\"\"\"\n    logging.debug(\"Detected mouse press event\")\n    if settings.windowDraggable:\n        if event.button() == QtCore.Qt.MouseButton.LeftButton:\n            self._isDragging = True\n            self._dragStartPosition = (\n                event.globalPosition().toPoint() - self.frameGeometry().topLeft()\n            )\n            event.accept()\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.mouseReleaseEvent","title":"<code>mouseReleaseEvent(event)</code>","text":"<p>Persist last window position upon releasing the mouse button.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>def mouseReleaseEvent(self, event):\n    \"\"\"Persist last window position upon releasing the mouse button.\"\"\"\n    logging.debug(\"Detected mouse release event\")\n    if settings.windowDraggable and event.button() == QtCore.Qt.MouseButton.LeftButton:\n        self._isDragging = False\n        windowPosition: QPoint = self.pos()\n        settings.windowPosX = windowPosition.x()\n        settings.windowPosY = windowPosition.y()\n        event.accept()\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.run","title":"<code>run()</code>  <code>staticmethod</code>","text":"<p>Create Qt application and start the window in the UI thread.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>@staticmethod\ndef run():\n    \"\"\"Create Qt application and start the window in the UI thread.\"\"\"\n    global window\n    global uiInvoker\n    application: QApplication = QApplication([])\n    uiInvoker = UiInvoker()\n    window = WindowManager()\n    if settings.windowShow:\n        window.show()\n\n    # Auto-close for CI smoke tests\n    try:\n        ms = int(os.getenv(\"VOICEKB_AUTOCLOSE_MS\", \"0\"))\n    except ValueError:\n        ms = 0\n    if ms &gt; 0:\n        QTimer.singleShot(ms, application.quit)\n\n    application.exec()\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.start","title":"<code>start()</code>  <code>staticmethod</code>","text":"<p>Spawn a daemon thread to run the Qt UI when enabled in settings.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>@staticmethod\ndef start():\n    \"\"\"Spawn a daemon thread to run the Qt UI when enabled in settings.\"\"\"\n    if not settings.windowShow:\n        return None\n    windowThread = threading.Thread(\n        target=WindowManager.run,\n        daemon=settings.windowDaemon,\n    )\n    windowThread.start()\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.WindowManager.wait_label","title":"<code>wait_label()</code>  <code>staticmethod</code>","text":"<p>Wait until the global label widget is created (used at startup).</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>@staticmethod\ndef wait_label():\n    \"\"\"Wait until the global label widget is created (used at startup).\"\"\"\n    global windowLabel\n    while True:\n        if windowLabel is not None:\n            return\n        time.sleep(0.1)\n</code></pre>"},{"location":"api/window/#voicekeyboard.window.invoke_in_ui","title":"<code>invoke_in_ui(fn)</code>","text":"<p>Invoke <code>fn</code> on the Qt UI thread if available.</p> <p>If the UI thread is not yet initialized, a warning is logged and the callable is not executed.</p> Source code in <code>voicekeyboard\\window.py</code> <pre><code>def invoke_in_ui(fn) -&gt; None:\n    \"\"\"Invoke ``fn`` on the Qt UI thread if available.\n\n    If the UI thread is not yet initialized, a warning is logged and the\n    callable is not executed.\n    \"\"\"\n    # Dispatch callable to Qt thread via signal\n    if uiInvoker is not None:\n        uiInvoker.callRequested.emit(fn)\n    else:\n        import logging\n\n        logging.warning(\"UiInvoker not initialized; callable not executed\")\n</code></pre>"}]}